
#include <cmath>

#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

vector<int> div(int n)
{
    vector<int> a ;
    a.push_back(1);
    int root = sqrt(n/2)+1;
    for(int i =1;i<root;i++)
    {
        for(int j=i+1;(i*i+j*j)<n;j++)
        {
            a.push_back(i*i+j*j);
        }

    }
    for(int i =0;2*((i<<2)+1)*((i<<2)+1)<n;i++)
    {
       a.push_back(2*((i<<2)+1)*((i<<2)+1));
    }
    sort(a.begin(),a.end());
    return a;
}
int bin_search(vector<int> a,int key)
{
    int front =0;
    int back = a.size()-1;
    int mid ; 

    while(front<= back)
    {
        mid = ((front+back)>>1);
        if(a[mid]==key)
        {
           return mid;
        }else if(a[mid]<key)
        {
         front = mid +1;
        }else{
            back = mid-1;
        }

    }
    return back;
}
 int sum_div(int n)
{
    //return int(n/log10(n));// not accurate but returns pretty good approximation
    int count=1;
    int i =1;
    int number_of_divisers=0;
    while(count<n)
    {
        int j =1;
        long int square = i*i +1;
        if((i&1)==0)//i is even 
        {
            while(j<i)
            {
                if (square%j==0){
                number_of_divisers+=1;
                }
                j+=4;
            }
        }else{
             square = square>>1;
             int root = sqrt(square) ;
            while(j<root)
            {
               
                if (square%j==0){
                number_of_divisers+=2;
                }
                j+=4;
            }
            if(root*root==square){number_of_divisers+=1;}
        }
      count+= number_of_divisers;
      i++;
      number_of_divisers=0;
      
    }
    return (--i);

}


vector<long long int> populate(vector< long long int> Alex,int T){
vector<int> divisors=div(T);
int div_size = divisors.size();
vector<int> Min(T+1);
Min[0] =1;
for(int i =1;i<T+1;i++)
{
    Min[i]= 1;
    Alex.push_back(i*(i+1)*(i*(i+1)+1));
}
for(int i =1;i<T+1;i++)
{
    long int sq = i*i+1;
    int j = bin_search(divisors,Min[i])+1;
    while((divisors[j]<i))
    {
    if(sq%divisors[j]==0)
    {
        for(int k=i;k<T+1;k+=divisors[j])
        {
         long int sq_k = k*k+1;
         Alex.push_back((k)*((sq_k<<1)-1+k*(divisors[j]+sq_k/divisors[j])));
         Min[k] = max(Min[k],divisors[j]);
        }
    }
     j++;
     if(j>=div_size){break;}

    }
    


}
sort(Alex.begin(), Alex.end()); 
//Alex = insertionSort(Alex);
return Alex;

    }




    /* Enter your code here. Read input from STDIN. Print output to STDOUT */  
int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(NULL);
    //
    int q=0;
    int Max=0;
    scanf("%d",&q);
    int a[q];
    for(int i =0;i<q;i++)
    {
      scanf("%d",a+i);
      Max = max(Max,a[i]);
    }
    int t = sum_div(Max+1);//t = sum_div(Max+1)===(Max+1)/log10(Max+1) approx
    //div[i] = sum(no.of divisors of t^2+1;for 1<=t<=i)
    vector<long long int> Alex;
    t = pow((t+1)/sqrt(2),4.0/3);
    //cout<<t<<" is T"<<endl;
    Alex = populate(Alex,t);
    for(int i=0;i<q;i++) {
        printf("%lld\n",Alex[(a[i]-1)]);
        
    }
   return 0;
        

     
}


